C51 COMPILER V9.00   LCD12864                                                              05/17/2017 12:41:02 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE LCD12864
OBJECT MODULE PLACED IN LCD12864.OBJ
COMPILER INVOKED BY: F:\keilc51\C51\BIN\C51.EXE LCD12864.c LARGE BROWSE DEBUG OBJECTEXTEND

line level    source

   1          #include "main.h"
   2                  /*16x16图标--------------------------------------------------------------------------*/
   3                  //PCtoLCD2002取模:顺向,逐行式/
   4             
   5          uchar code bmp1616[3][32]=
   6          {
   7                  //"℃"    tt=0
   8                  {
   9                  0x00,0x00,0x30,0x00,0x48,0x00,0x49,0xC0,0x33,0xE8,0x06,0x38,0x0C,0x18,0x0C,0x08,
  10                  0x0C,0x00,0x0C,0x00,0x0C,0x00,0x0C,0x00,0x06,0x08,0x03,0x10,0x01,0xE0,0x00,0x00
  11                  },     
  12                  
  13                  //温度计图标
  14                  {
  15                  0x00,0x00,0x01,0x80,0x02,0x40,0x02,0xC0,0x02,0x40,0x02,0xC0,0x02,0x40,0x02,0xC0,
  16                  0x02,0x40,0x03,0xC0,0x07,0xE0,0x0F,0xF0,0x0F,0xF0,0x07,0xE0,0x03,0xC0,0x00,0x00
  17                  }
  18          };
  19          
  20                   
  21          /*12864液晶显示屏并口驱动程序--------------------------------------------------------*/
  22          //检查忙位
  23          void chk_busy()
  24          {
  25   1         LCM_RS=0; LCM_RW=1; LCM_EN=1;
  26   1         Lcd_Bus=0xff;
  27   1         while((Lcd_Bus&0x80)==0x80);
  28   1         LCM_EN=0;
  29   1      }
  30          /*写指令到LCD------------------------------------------------------------------------*/
  31          void write_com(uchar cmdcode)
  32          {
  33   1              chk_busy();
  34   1              LCM_RS=0; LCM_RW=0; LCM_EN=1;
  35   1              Lcd_Bus=cmdcode;
  36   1              LCM_EN=0;
  37   1      }
  38          /*写数据到LCD------------------------------------------------------------------------*/
  39          void write_data(uchar Dispdata)
  40          {        
  41   1              chk_busy();
  42   1              LCM_RS=1; LCM_RW=0; LCM_EN=1;
  43   1              Lcd_Bus=Dispdata;
  44   1              LCM_EN=0;
  45   1      }
  46          /*向LCM发送一个字符串,长度64字符之内-------------------------------------------------*/
  47          void lcm_w_word(uchar *s)
  48          {
  49   1              while(*s>0) { write_data(*s); s++; }  //应用：lcm_w_word("您好！");
  50   1      }
  51          /******************************************************************************/
  52          void lcm_w_test(bit i,unsigned char word){//写指令或数据（被调用层）
  53   1              if(i == 0){
  54   2                      write_com(word);//写指令（0，指令）
  55   2              }else{
C51 COMPILER V9.00   LCD12864                                                              05/17/2017 12:41:02 PAGE 2   

  56   2                      write_data(word);//写数据（1，数据）
  57   2              }
  58   1      }
  59          /*清屏函数--------------------------------------------------------------------------*/
  60          void lcm_clr(void)
  61          {
  62   1              write_com(0x01);        
  63   1      }
  64          
  65          /******************************************************************************/
  66          
  67          void lcm_clr2(void){//清屏上面3行（用空格填满要清显示的地方，因为液晶屏是静态显示的，所以这办法常用）
  68   1              lcm_w_test(0,0x80);//第一行
  69   1              lcm_w_word("                ");
  70   1                  //标尺("1234567812345678"应该能够显示满一行)
  71   1         lcm_w_test(0,0x90);//第二行
  72   1              lcm_w_word("                ");
  73   1                  //标尺("1234567812345678"应该能够显示满一行)
  74   1         lcm_w_test(0,0x88);//第一行
  75   1              lcm_w_word("                ");
  76   1                  //标尺("1234567812345678"应该能够显示满一行)
  77   1      }
  78          
  79          /*初始化LCD屏------------------------------------------------------------------------*/
  80          void lcm_init()
  81          {       
  82   1          LCM_RST=0;
  83   1          LCM_RST=1;
  84   1              LCM_PSB=1; 
  85   1              write_com(0x30);  //选择8bit数据流
  86   1              write_com(0x0c);  //开显示(无游标、不反白)
  87   1              lcm_clr();        //清除显示，并且设定地址指针为00H
  88   1              write_com(0x06);  //光标右移,DDRAM位址计数器(AC)加1,不整屏移动
  89   1      lcm_clr2();
  90   1      }
  91          /*使用绘图的方法让一个16*16的汉字符反白----------------------------------------------*/
  92          //形式参数:uchar x,uchar y,uchar wide,uchar bkcor
  93          //行参说明:坐标水平位置,坐标垂直位置,反白行数,要反白还是清除(1:反白,0:清除)   
  94          void write1616GDRAM(uchar x,uchar y,uchar sign,uchar *bmp)      
  95          { 
  96   1              uchar i,j,basex;
  97   1              write_com(0x36);      //扩展指令，绘图模式命令，开显示也可以绘.(关图片显示0x34)
  98   1              if(y==1||y==2)    //第一第二行
  99   1              {
 100   2                      basex=0x80;        //上半屏
 101   2                      y=(y-1)*16;       //垂直位址从0X80开始.
 102   2              }
 103   1              if(y==3||y==4)  //第三第四行
 104   1              {
 105   2                      basex=0x88;      //下半屏
 106   2                      y=(y-3)*16;      //垂直位址都是从0X80开始的，不管上下半屏。
 107   2              }
 108   1              for(i=0;i<16;i++)       //
 109   1              {                                                                                                                       
 110   2                      write_com(0x80+y+i);  //写入垂直位址。
 111   2                      write_com(basex+x-1); //再写入水平位址(上半屏第一字为0X80，……第七字为0X87)
 112   2                                                                 //下半屏第一字为0X88，……第七字为0X8F；
 113   2                      for(j=0;j<2;j++)   //再写入两个8位元的数据,AC会自动增一，接着写数据
 114   2                      {
 115   3                              if(sign==1)  
 116   3                                      write_data(~(*bmp++));
 117   3                              else  
C51 COMPILER V9.00   LCD12864                                                              05/17/2017 12:41:02 PAGE 3   

 118   3                                      write_data(*bmp++);
 119   3                      }
 120   2              }       
 121   1              write_com(0x36);  //写完数据，开图片显示     
 122   1      }
 123          
 124          /**************************************************************************************
 125          //函数功能:显示16X16图形,适用于st7920型液晶
 126          //形式参数:uchar x,uchar y,uchar *bmp
 127          //行参说明:横坐标X列，纵坐标Y行，sign=1反白、=0不反，tt是要显示的图形bmp1616中的第几个
 128          //************************************************************************************/ 
 129          void set1616pic(uchar x,uchar y,uchar sign,uchar tt) 
 130          {
 131   1              uchar (*pp)[32];         //定义指针
 132   1              pp=bmp1616;       //二维数组首地址给指针，故指针指向下一个数组地址应为加64
 133   1              write1616GDRAM(x,y,sign,pp[tt]); //写入小时的十位         
 134   1      }
 135          /**************************************************************************************
 136          //函数功能:显示16X32图形,适用于st7920型液晶
 137          //形式参数:uchar x,uchar y,uchar *bmp
 138          //行参说明:横坐标X列，纵坐标Y行，要显示的图形BMP
 139          //************************************************************************************/           
 140          void write1632GDRAM(uchar x,uchar y,uchar *bmp) 
 141          { 
 142   1              uchar i,j,basex,basey;
 143   1              switch(y)        //由y纵坐标定是上半屏还是下半屏
 144   1              {
 145   2                case 1: basex=0x80; break;  //上半屏
 146   2                case 2: basex=0x80; break;  //先上半屏，下面再下半屏。
 147   2                case 3: basex=0x88; break;  //下半屏
 148   2                default:   return;   //别的则返回
 149   2              }
 150   1              basey=basex+x-1;
 151   1              write_com(0x36);  
 152   1              if(y==1||y==3)  //如为第一第三行，则直接是在同一半屏，直接绘完32行点陈数据。
 153   1              {
 154   2                        for(i=0;i<32;i++)      //写入32行点阵
 155   2                        {                                                                                                             
 156   3                                  write_com(0x80+i);  //先写入垂直位址,选上下32行的哪一行,不管上下半屏，首行都为0X80
 157   3                                  write_com(basey);     //再写入水平位址(选上下半屏)
 158   3                                  for(j=0;j<2;j++)           //2个8位元的数据,即16BIT宽度
 159   3                                      write_data(*bmp++);   
 160   3                        }      
 161   2              }
 162   1              if(y==2)  //从第二行开始则画图将上下半屏都有，所以先画完上半屏16行，再画下半屏16行。
 163   1              {                                       
 164   2                        for(i=0;i<16;i++)      //写入上半屏16行点阵
 165   2                        {                                                                                                             
 166   3                                  write_com(0x90+i);  //先写入垂直位址,选上下32行的哪一行,不管上下半屏，首行都为0X80，第二行为0X90。
 167   3                                  write_com(basey);    //(选上半屏)再写入水平位址
 168   3                                  for(j=0;j<2;j++)           //2个8位元的数据,即16BIT宽度
 169   3                                      write_data(*bmp++);   
 170   3                        }
 171   2                        for(i=0;i<16;i++)      //写入下半屏16行点阵
 172   2                        {                                                                                                             
 173   3                                  write_com(0x80+i);  //先写入垂直位址,选上下32行的哪一行,不管上下半屏，首行都为0X80
 174   3                                  write_com(basey+8);   //(选下半屏)再写入水平位址
 175   3                                  for(j=0;j<2;j++)           //2个8位元的数据,即16BIT宽度
 176   3                                      write_data(*bmp++);   
 177   3                        }      
 178   2              }
 179   1              write_com(0x36);  //写完数据，开图片显示     
C51 COMPILER V9.00   LCD12864                                                              05/17/2017 12:41:02 PAGE 4   

 180   1      }
 181          /**************************************************************************************        
 182          ** 函数名称: init_12864_GDRAM()
 183          ** 功能描述: 在程写GDRAM时序初始化12864 
 184          **************************************************************************************/
 185          void init_12864_GDRAM()  
 186          {
 187   1              write_com(0x30);     //基本指令操作(扩充指令操作为:0x34)
 188   1              write_com(0x0C);     //整体显示ON，游标OFF，游标位置OFF
 189   1              write_com(0x06);         //光标右移,DDRAM位址计数器(AC)加1,不整屏移动
 190   1              lcm_clr();           //清屏 (清DDRAM)
 191   1      }
 192          
 193          /**************************************************************************************
 194          //函数名称:Clean_12864_GDRAM(void)                                              
 195          //函数功能:清屏函数
 196          //使用说明:GDRAM填满0
 197          //************************************************************************************/
 198          void Clean_12864_GDRAM(void)
 199          {
 200   1          uchar x,y;
 201   1          write_com(0x36);
 202   1          init_12864_GDRAM();         //设置扩展指令集，按手册说明，仅设置了绘图位，
 203   1          write_com(0x36);    //需要两次，本次设置扩展指令集。
 204   1          for (y=0;y<32;y++)
 205   1          {
 206   2              write_com(0x80+y);  //设置y=1000+00xx，y+1则往下一行
 207   2              write_com(0x80);        //设置x=1000 0000
 208   2              for (x=0;x<16;x++)
 209   2              {
 210   3                  write_data(0x00);   //高字节数据
 211   3                  write_data(0x00);   //低字节数据
 212   3              }
 213   2          }
 214   1      }
 215          /*-----------------------------------------------------------------------------------*/ 


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    646    ----
   CONSTANT SIZE    =    113    ----
   XDATA SIZE       =   ----      18
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       1
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
